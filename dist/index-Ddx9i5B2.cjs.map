{"version":3,"file":"index-Ddx9i5B2.cjs","sources":["../node_modules/viem/_esm/utils/data/isHex.js","../node_modules/viem/_esm/utils/data/size.js","../node_modules/viem/_esm/errors/version.js","../node_modules/viem/_esm/errors/utils.js","../node_modules/viem/_esm/errors/base.js","../node_modules/viem/_esm/errors/data.js","../node_modules/viem/_esm/utils/data/pad.js","../node_modules/viem/_esm/errors/encoding.js","../node_modules/viem/_esm/utils/data/trim.js","../node_modules/viem/_esm/utils/encoding/fromHex.js","../node_modules/viem/_esm/utils/encoding/toHex.js","../node_modules/viem/_esm/utils/encoding/toBytes.js"],"sourcesContent":["export function isHex(value, { strict = true } = {}) {\n    if (!value)\n        return false;\n    if (typeof value !== 'string')\n        return false;\n    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');\n}\n//# sourceMappingURL=isHex.js.map","import { isHex } from './isHex.js';\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value) {\n    if (isHex(value, { strict: false }))\n        return Math.ceil((value.length - 2) / 2);\n    return value.length;\n}\n//# sourceMappingURL=size.js.map","export const version = '2.12.0';\n//# sourceMappingURL=version.js.map","import { version } from './version.js';\nexport const getContractAddress = (address) => address;\nexport const getUrl = (url) => url;\nexport const getVersion = () => `viem@${version}`;\n//# sourceMappingURL=utils.js.map","import { getVersion } from './utils.js';\nexport class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        super();\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ViemError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getVersion()\n        });\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        this.message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath\n                ? [\n                    `Docs: https://viem.sh${docsPath}${args.docsSlug ? `#${args.docsSlug}` : ''}`,\n                ]\n                : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: ${this.version}`,\n        ].join('\\n');\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=base.js.map","import { BaseError } from './base.js';\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \"${offset}\" is out-of-bounds (size: ${size}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SliceOffsetOutOfBoundsError'\n        });\n    }\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SizeExceedsPaddingSizeError'\n        });\n    }\n}\nexport class InvalidBytesLengthError extends BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidBytesLengthError'\n        });\n    }\n}\n//# sourceMappingURL=data.js.map","import { SizeExceedsPaddingSizeError, } from '../../errors/data.js';\nexport function pad(hexOrBytes, { dir, size = 32 } = {}) {\n    if (typeof hexOrBytes === 'string')\n        return padHex(hexOrBytes, { dir, size });\n    return padBytes(hexOrBytes, { dir, size });\n}\nexport function padHex(hex_, { dir, size = 32 } = {}) {\n    if (size === null)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\nexport function padBytes(bytes, { dir, size = 32 } = {}) {\n    if (size === null)\n        return bytes;\n    if (bytes.length > size)\n        throw new SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n//# sourceMappingURL=pad.js.map","import { BaseError } from './base.js';\nexport class IntegerOutOfRangeError extends BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \"${value}\" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'IntegerOutOfRangeError'\n        });\n    }\n}\nexport class InvalidBytesBooleanError extends BaseError {\n    constructor(bytes) {\n        super(`Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidBytesBooleanError'\n        });\n    }\n}\nexport class InvalidHexBooleanError extends BaseError {\n    constructor(hex) {\n        super(`Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidHexBooleanError'\n        });\n    }\n}\nexport class InvalidHexValueError extends BaseError {\n    constructor(value) {\n        super(`Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidHexValueError'\n        });\n    }\n}\nexport class SizeOverflowError extends BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SizeOverflowError'\n        });\n    }\n}\n//# sourceMappingURL=encoding.js.map","export function trim(hexOrBytes, { dir = 'left' } = {}) {\n    let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (typeof hexOrBytes === 'string') {\n        if (data.length === 1 && dir === 'right')\n            data = `${data}0`;\n        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;\n    }\n    return data;\n}\n//# sourceMappingURL=trim.js.map","import { InvalidHexBooleanError, SizeOverflowError, } from '../../errors/encoding.js';\nimport { size as size_ } from '../data/size.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBytes } from './toBytes.js';\nexport function assertSize(hexOrBytes, { size }) {\n    if (size_(hexOrBytes) > size)\n        throw new SizeOverflowError({\n            givenSize: size_(hexOrBytes),\n            maxSize: size,\n        });\n}\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex(hex, toOrOpts) {\n    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;\n    const to = opts.to;\n    if (to === 'number')\n        return hexToNumber(hex, opts);\n    if (to === 'bigint')\n        return hexToBigInt(hex, opts);\n    if (to === 'string')\n        return hexToString(hex, opts);\n    if (to === 'boolean')\n        return hexToBool(hex, opts);\n    return hexToBytes(hex, opts);\n}\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex, opts = {}) {\n    const { signed } = opts;\n    if (opts.size)\n        assertSize(hex, { size: opts.size });\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n    if (value <= max)\n        return value;\n    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;\n}\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = trim(hex);\n    }\n    if (trim(hex) === '0x00')\n        return false;\n    if (trim(hex) === '0x01')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex, opts = {}) {\n    return Number(hexToBigInt(hex, opts));\n}\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex, opts = {}) {\n    let bytes = hexToBytes(hex);\n    if (opts.size) {\n        assertSize(bytes, { size: opts.size });\n        bytes = trim(bytes, { dir: 'right' });\n    }\n    return new TextDecoder().decode(bytes);\n}\n//# sourceMappingURL=fromHex.js.map","import { IntegerOutOfRangeError, } from '../../errors/encoding.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToHex(value, opts);\n    if (typeof value === 'string') {\n        return stringToHex(value, opts);\n    }\n    if (typeof value === 'boolean')\n        return boolToHex(value, opts);\n    return bytesToHex(value, opts);\n}\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value, opts = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof opts.size === 'number') {\n        assertSize(hex, { size: opts.size });\n        return pad(hex, { size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value, opts = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++) {\n        string += hexes[value[i]];\n    }\n    const hex = `0x${string}`;\n    if (typeof opts.size === 'number') {\n        assertSize(hex, { size: opts.size });\n        return pad(hex, { dir: 'right', size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(value_, opts = {}) {\n    const { signed, size } = opts;\n    const value = BigInt(value_);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value_ === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value > maxValue) || value < minValue) {\n        const suffix = typeof value_ === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value_}${suffix}`,\n        });\n    }\n    const hex = `0x${(signed && value < 0\n        ? (1n << BigInt(size * 8)) + BigInt(value)\n        : value).toString(16)}`;\n    if (size)\n        return pad(hex, { size });\n    return hex;\n}\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_, opts = {}) {\n    const value = encoder.encode(value_);\n    return bytesToHex(value, opts);\n}\n//# sourceMappingURL=toHex.js.map","import { BaseError } from '../../errors/base.js';\nimport { isHex } from '../data/isHex.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nimport { numberToHex, } from './toHex.js';\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToBytes(value, opts);\n    if (typeof value === 'boolean')\n        return boolToBytes(value, opts);\n    if (isHex(value))\n        return hexToBytes(value, opts);\n    return stringToBytes(value, opts);\n}\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value, opts = {}) {\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof opts.size === 'number') {\n        assertSize(bytes, { size: opts.size });\n        return pad(bytes, { size: opts.size });\n    }\n    return bytes;\n}\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = pad(hex, { dir: 'right', size: opts.size });\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value, opts) {\n    const hex = numberToHex(value, opts);\n    return hexToBytes(hex);\n}\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(value, opts = {}) {\n    const bytes = encoder.encode(value);\n    if (typeof opts.size === 'number') {\n        assertSize(bytes, { size: opts.size });\n        return pad(bytes, { dir: 'right', size: opts.size });\n    }\n    return bytes;\n}\n//# sourceMappingURL=toBytes.js.map"],"names":["isHex","value","strict","size","version","getVersion","BaseError","shortMessage","args","details","_a","docsPath","fn","walk","err","SizeExceedsPaddingSizeError","targetSize","type","pad","hexOrBytes","dir","padHex","padBytes","hex_","hex","bytes","paddedBytes","padEnd","IntegerOutOfRangeError","max","min","signed","InvalidHexBooleanError","SizeOverflowError","givenSize","maxSize","trim","data","sliceLength","assertSize","size_","fromHex","toOrOpts","opts","to","hexToNumber","hexToBigInt","hexToString","hexToBool","hexToBytes","hexes","_v","i","toHex","numberToHex","stringToHex","boolToHex","bytesToHex","string","value_","maxValue","minValue","suffix","encoder","charCodeMap","charCodeToBase16","char","hexString","length","index","j","nibbleLeft","nibbleRight"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}