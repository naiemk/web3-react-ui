{"version":3,"file":"index-C38Xa293.js","sources":["../node_modules/viem/_esm/utils/data/isHex.js","../node_modules/viem/_esm/utils/data/size.js","../node_modules/viem/_esm/errors/version.js","../node_modules/viem/_esm/errors/utils.js","../node_modules/viem/_esm/errors/base.js","../node_modules/viem/_esm/errors/data.js","../node_modules/viem/_esm/utils/data/pad.js","../node_modules/viem/_esm/errors/encoding.js","../node_modules/viem/_esm/utils/data/trim.js","../node_modules/viem/_esm/utils/encoding/fromHex.js","../node_modules/viem/_esm/utils/encoding/toHex.js","../node_modules/viem/_esm/utils/encoding/toBytes.js"],"sourcesContent":["export function isHex(value, { strict = true } = {}) {\n    if (!value)\n        return false;\n    if (typeof value !== 'string')\n        return false;\n    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');\n}\n//# sourceMappingURL=isHex.js.map","import { isHex } from './isHex.js';\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value) {\n    if (isHex(value, { strict: false }))\n        return Math.ceil((value.length - 2) / 2);\n    return value.length;\n}\n//# sourceMappingURL=size.js.map","export const version = '2.12.0';\n//# sourceMappingURL=version.js.map","import { version } from './version.js';\nexport const getContractAddress = (address) => address;\nexport const getUrl = (url) => url;\nexport const getVersion = () => `viem@${version}`;\n//# sourceMappingURL=utils.js.map","import { getVersion } from './utils.js';\nexport class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        super();\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ViemError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getVersion()\n        });\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        this.message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath\n                ? [\n                    `Docs: https://viem.sh${docsPath}${args.docsSlug ? `#${args.docsSlug}` : ''}`,\n                ]\n                : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: ${this.version}`,\n        ].join('\\n');\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=base.js.map","import { BaseError } from './base.js';\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \"${offset}\" is out-of-bounds (size: ${size}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SliceOffsetOutOfBoundsError'\n        });\n    }\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SizeExceedsPaddingSizeError'\n        });\n    }\n}\nexport class InvalidBytesLengthError extends BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidBytesLengthError'\n        });\n    }\n}\n//# sourceMappingURL=data.js.map","import { SizeExceedsPaddingSizeError, } from '../../errors/data.js';\nexport function pad(hexOrBytes, { dir, size = 32 } = {}) {\n    if (typeof hexOrBytes === 'string')\n        return padHex(hexOrBytes, { dir, size });\n    return padBytes(hexOrBytes, { dir, size });\n}\nexport function padHex(hex_, { dir, size = 32 } = {}) {\n    if (size === null)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\nexport function padBytes(bytes, { dir, size = 32 } = {}) {\n    if (size === null)\n        return bytes;\n    if (bytes.length > size)\n        throw new SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n//# sourceMappingURL=pad.js.map","import { BaseError } from './base.js';\nexport class IntegerOutOfRangeError extends BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \"${value}\" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'IntegerOutOfRangeError'\n        });\n    }\n}\nexport class InvalidBytesBooleanError extends BaseError {\n    constructor(bytes) {\n        super(`Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidBytesBooleanError'\n        });\n    }\n}\nexport class InvalidHexBooleanError extends BaseError {\n    constructor(hex) {\n        super(`Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidHexBooleanError'\n        });\n    }\n}\nexport class InvalidHexValueError extends BaseError {\n    constructor(value) {\n        super(`Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidHexValueError'\n        });\n    }\n}\nexport class SizeOverflowError extends BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SizeOverflowError'\n        });\n    }\n}\n//# sourceMappingURL=encoding.js.map","export function trim(hexOrBytes, { dir = 'left' } = {}) {\n    let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (typeof hexOrBytes === 'string') {\n        if (data.length === 1 && dir === 'right')\n            data = `${data}0`;\n        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;\n    }\n    return data;\n}\n//# sourceMappingURL=trim.js.map","import { InvalidHexBooleanError, SizeOverflowError, } from '../../errors/encoding.js';\nimport { size as size_ } from '../data/size.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBytes } from './toBytes.js';\nexport function assertSize(hexOrBytes, { size }) {\n    if (size_(hexOrBytes) > size)\n        throw new SizeOverflowError({\n            givenSize: size_(hexOrBytes),\n            maxSize: size,\n        });\n}\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex(hex, toOrOpts) {\n    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;\n    const to = opts.to;\n    if (to === 'number')\n        return hexToNumber(hex, opts);\n    if (to === 'bigint')\n        return hexToBigInt(hex, opts);\n    if (to === 'string')\n        return hexToString(hex, opts);\n    if (to === 'boolean')\n        return hexToBool(hex, opts);\n    return hexToBytes(hex, opts);\n}\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex, opts = {}) {\n    const { signed } = opts;\n    if (opts.size)\n        assertSize(hex, { size: opts.size });\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n    if (value <= max)\n        return value;\n    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;\n}\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = trim(hex);\n    }\n    if (trim(hex) === '0x00')\n        return false;\n    if (trim(hex) === '0x01')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex, opts = {}) {\n    return Number(hexToBigInt(hex, opts));\n}\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex, opts = {}) {\n    let bytes = hexToBytes(hex);\n    if (opts.size) {\n        assertSize(bytes, { size: opts.size });\n        bytes = trim(bytes, { dir: 'right' });\n    }\n    return new TextDecoder().decode(bytes);\n}\n//# sourceMappingURL=fromHex.js.map","import { IntegerOutOfRangeError, } from '../../errors/encoding.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToHex(value, opts);\n    if (typeof value === 'string') {\n        return stringToHex(value, opts);\n    }\n    if (typeof value === 'boolean')\n        return boolToHex(value, opts);\n    return bytesToHex(value, opts);\n}\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value, opts = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof opts.size === 'number') {\n        assertSize(hex, { size: opts.size });\n        return pad(hex, { size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value, opts = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++) {\n        string += hexes[value[i]];\n    }\n    const hex = `0x${string}`;\n    if (typeof opts.size === 'number') {\n        assertSize(hex, { size: opts.size });\n        return pad(hex, { dir: 'right', size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(value_, opts = {}) {\n    const { signed, size } = opts;\n    const value = BigInt(value_);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value_ === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value > maxValue) || value < minValue) {\n        const suffix = typeof value_ === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value_}${suffix}`,\n        });\n    }\n    const hex = `0x${(signed && value < 0\n        ? (1n << BigInt(size * 8)) + BigInt(value)\n        : value).toString(16)}`;\n    if (size)\n        return pad(hex, { size });\n    return hex;\n}\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_, opts = {}) {\n    const value = encoder.encode(value_);\n    return bytesToHex(value, opts);\n}\n//# sourceMappingURL=toHex.js.map","import { BaseError } from '../../errors/base.js';\nimport { isHex } from '../data/isHex.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nimport { numberToHex, } from './toHex.js';\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToBytes(value, opts);\n    if (typeof value === 'boolean')\n        return boolToBytes(value, opts);\n    if (isHex(value))\n        return hexToBytes(value, opts);\n    return stringToBytes(value, opts);\n}\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value, opts = {}) {\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof opts.size === 'number') {\n        assertSize(bytes, { size: opts.size });\n        return pad(bytes, { size: opts.size });\n    }\n    return bytes;\n}\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = pad(hex, { dir: 'right', size: opts.size });\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value, opts) {\n    const hex = numberToHex(value, opts);\n    return hexToBytes(hex);\n}\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(value, opts = {}) {\n    const bytes = encoder.encode(value);\n    if (typeof opts.size === 'number') {\n        assertSize(bytes, { size: opts.size });\n        return pad(bytes, { dir: 'right', size: opts.size });\n    }\n    return bytes;\n}\n//# sourceMappingURL=toBytes.js.map"],"names":["isHex","value","strict","size","version","getVersion","BaseError","shortMessage","args","details","_a","docsPath","fn","walk","err","SizeExceedsPaddingSizeError","targetSize","type","pad","hexOrBytes","dir","padHex","padBytes","hex_","hex","bytes","paddedBytes","padEnd","IntegerOutOfRangeError","max","min","signed","InvalidHexBooleanError","SizeOverflowError","givenSize","maxSize","trim","data","sliceLength","assertSize","size_","fromHex","toOrOpts","opts","to","hexToNumber","hexToBigInt","hexToString","hexToBool","hexToBytes","hexes","_v","i","toHex","numberToHex","stringToHex","boolToHex","bytesToHex","string","value_","maxValue","minValue","suffix","encoder","charCodeMap","charCodeToBase16","char","hexString","length","index","j","nibbleLeft","nibbleRight"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}